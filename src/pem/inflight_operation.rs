use std::cmp::Ordering;

use super::types::{Addr, Const, Reg, Value};

struct OperationLatency;
impl OperationLatency {
    const LDI: usize = 1;
    const LDR: usize = 5;
    const STR: usize = 5;
    const ADD: usize = 2;
    const SUB: usize = 2;
    const MUL: usize = 10;
}

/// Output of an operation
///
/// We consider two operations to be equal if they write to the same register or
/// memory address and the ordering of operations is determined by the tuple
/// `(output_type, register/memory_address)`. Two outputs writing to the same
/// register/memory address are considered equal regardless of the values.
#[derive(Debug)]
pub(super) enum OperationOutput {
    WriteToRegister(Reg, Value),
    WriteToMemory(Addr, Value),
}

impl Ord for OperationOutput {
    fn cmp(&self, other: &Self) -> Ordering {
        match (self, other) {
            (Self::WriteToRegister(dst1, _), Self::WriteToRegister(dst2, _)) => dst1.0.cmp(&dst2.0),
            (Self::WriteToMemory(addr1, _), Self::WriteToMemory(addr2, _)) => addr1.0.cmp(&addr2.0),
            (Self::WriteToRegister(_, _), Self::WriteToMemory(_, _)) => Ordering::Less,
            (Self::WriteToMemory(_, _), Self::WriteToRegister(_, _)) => Ordering::Greater,
        }
    }
}

impl PartialOrd for OperationOutput {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Eq for OperationOutput {}

impl PartialEq for OperationOutput {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Self::WriteToRegister(dst1, _), Self::WriteToRegister(dst2, _)) => dst1.0 == dst2.0,
            (Self::WriteToMemory(addr1, _), Self::WriteToMemory(addr2, _)) => addr1.0 == addr2.0,
            _ => false,
        }
    }
}

/// An operation that is currently in flight and will complete just before
/// `complete_cycle` starts with OperationOutput `output`. The operation is
/// generated by the #`instruction`
#[derive(Debug, Eq)]
pub(super) struct InflightOperation {
    /// Operation output when it completes
    output: OperationOutput,
    /// Cycle when the operation completes
    complete_cycle: usize,
    /// The instruction that generated this operation
    instruction: usize,
}

impl Ord for InflightOperation {
    fn cmp(&self, other: &Self) -> Ordering {
        match self.complete_cycle.cmp(&other.complete_cycle) {
            Ordering::Equal => self.output.cmp(&other.output),
            ordering => ordering.reverse(),
        }
    }
}

impl PartialOrd for InflightOperation {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl PartialEq for InflightOperation {
    fn eq(&self, other: &Self) -> bool {
        self.complete_cycle == other.complete_cycle
            && self.output == other.output
            && self.instruction == other.instruction
    }
}

impl InflightOperation {
    /// Load a 32-bit numeric constant into a register
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `dst` - destination register
    /// * `constant` - constant to load
    pub fn from_ldi(cycle: usize, dst: Reg, constant: Const) -> Self {
        Self {
            output: OperationOutput::WriteToRegister(dst, Value(constant.0.to_string())),
            complete_cycle: cycle + OperationLatency::LDI,
            instruction: cycle,
        }
    }

    /// Load a value from memory into a register
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `dst` - destination register
    /// * `addr_value` - value of the memory address to load from
    pub fn from_ldr(cycle: usize, dst: Reg, addr_value: Value) -> Self {
        Self {
            output: OperationOutput::WriteToRegister(dst, addr_value),
            complete_cycle: cycle + OperationLatency::LDR,
            instruction: cycle,
        }
    }

    /// Store a value from a register into memory
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `src_value` - value of the source register
    /// * `addr` - memory address to store into
    pub fn from_str(cycle: usize, src_value: Value, addr: Addr) -> Self {
        Self {
            output: OperationOutput::WriteToMemory(addr, src_value),
            complete_cycle: cycle + OperationLatency::STR,
            instruction: cycle,
        }
    }

    /// Add the values in the source registers and put the sum in the
    /// destination register
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `dst` - destination register
    /// * `src1_value` - value of the first source register
    /// * `src2_value` - value of the second source register
    pub fn from_add(cycle: usize, dst: Reg, src1_value: Value, src2_value: Value) -> Self {
        Self {
            output: OperationOutput::WriteToRegister(
                dst,
                Value(format!("({} + {})", src2_value.0, src1_value.0)),
            ),
            complete_cycle: cycle + OperationLatency::ADD,
            instruction: cycle,
        }
    }

    /// Subtract the value of source register 2 from source register 1 and put
    /// the difference in the destination register
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `dst` - destination register
    /// * `src1_value` - value of the first source register
    /// * `src2_value` - value of the second source register
    pub fn from_sub(cycle: usize, dst: Reg, src1_value: Value, src2_value: Value) -> Self {
        Self {
            output: OperationOutput::WriteToRegister(
                dst,
                Value(format!("({} - {})", src1_value.0, src2_value.0)),
            ),
            complete_cycle: cycle + OperationLatency::SUB,
            instruction: cycle,
        }
    }

    /// Multiply the values in the source registers and put the product in the
    /// destination register
    ///
    /// # Arguments
    /// * `cycle` - cycle when the operation starts
    /// * `dst` - destination register
    /// * `src1_value` - value of the first source register
    /// * `src2_value` - value of the second source register
    pub fn from_mul(cycle: usize, dst: Reg, src1_value: Value, src2_value: Value) -> Self {
        Self {
            output: OperationOutput::WriteToRegister(
                dst,
                Value(format!("({} * {})", src1_value.0, src2_value.0)),
            ),
            complete_cycle: cycle + OperationLatency::MUL,
            instruction: cycle,
        }
    }

    pub fn get_output(&self) -> &OperationOutput {
        &self.output
    }

    pub fn get_complete_cycle(&self) -> usize {
        self.complete_cycle
    }

    pub fn get_instruction(&self) -> usize {
        self.instruction
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_inflight_operation_ordering() {
        let ldi = InflightOperation::from_ldi(0, Reg(0), Const(1));
        let ldr = InflightOperation::from_ldr(0, Reg(0), Value("1".to_string()));
        let str = InflightOperation::from_str(0, Value("1".to_string()), Addr(0));
        let add =
            InflightOperation::from_add(0, Reg(0), Value("1".to_string()), Value("2".to_string()));
        let sub =
            InflightOperation::from_sub(0, Reg(0), Value("1".to_string()), Value("2".to_string()));
        let mul =
            InflightOperation::from_mul(0, Reg(0), Value("1".to_string()), Value("2".to_string()));

        assert_eq!(ldi, ldi);
        assert_eq!(ldr, ldr);
        assert_eq!(str, str);
        assert_eq!(add, add);
        assert_eq!(sub, sub);
        assert_eq!(mul, mul);

        assert!(ldi > ldr);
        assert!(ldi > str);
        assert!(ldi > add);
        assert!(ldi > sub);
        assert!(ldi > mul);

        assert!(ldr < str);
        assert!(ldr < add);
        assert!(ldr < sub);
        assert!(ldr > mul);

        assert!(str < add);
        assert!(str < sub);
        assert!(str > mul);

        assert!(add == sub);
        assert!(add > mul);

        assert!(sub > mul)
    }

    #[test]
    fn test_inflight_operation_ldi() {
        let ldi = InflightOperation::from_ldi(0, Reg(0), Const(1));
        assert_eq!(
            ldi.get_output(),
            &OperationOutput::WriteToRegister(Reg(0), Value("1".to_string()))
        );
        assert_eq!(ldi.get_complete_cycle(), OperationLatency::LDI);
        assert_eq!(ldi.get_instruction(), 0);
    }

    #[test]
    fn test_inflight_operation_ldr() {
        let ldr = InflightOperation::from_ldr(0, Reg(0), Value("1".to_string()));
        assert_eq!(
            ldr.get_output(),
            &OperationOutput::WriteToRegister(Reg(0), Value("1".to_string()))
        );
        assert_eq!(ldr.get_complete_cycle(), OperationLatency::LDR);
        assert_eq!(ldr.get_instruction(), 0);
    }

    #[test]
    fn test_inflight_operation_str() {
        let str_ = InflightOperation::from_str(0, Value("1".to_string()), Addr(0));
        assert_eq!(
            str_.get_output(),
            &OperationOutput::WriteToMemory(Addr(0), Value("1".to_string()))
        );
        assert_eq!(str_.get_complete_cycle(), OperationLatency::STR);
        assert_eq!(str_.get_instruction(), 0);
    }

    #[test]
    fn test_inflight_operation_add() {
        let add =
            InflightOperation::from_add(0, Reg(0), Value("1".to_string()), Value("2".to_string()));
        assert_eq!(
            add.get_output(),
            &OperationOutput::WriteToRegister(Reg(0), Value("(2 + 1)".to_string()))
        );
        assert_eq!(add.get_complete_cycle(), OperationLatency::ADD);
        assert_eq!(add.get_instruction(), 0);
    }

    #[test]
    fn test_inflight_operation_sub() {
        let sub =
            InflightOperation::from_sub(0, Reg(0), Value("1".to_string()), Value("2".to_string()));
        assert_eq!(
            sub.get_output(),
            &OperationOutput::WriteToRegister(Reg(0), Value("(1 - 2)".to_string()))
        );
        assert_eq!(sub.get_complete_cycle(), OperationLatency::SUB);
        assert_eq!(sub.get_instruction(), 0);
    }

    #[test]
    fn test_inflight_operation_mul() {
        let mul =
            InflightOperation::from_mul(0, Reg(0), Value("1".to_string()), Value("2".to_string()));
        assert_eq!(
            mul.get_output(),
            &OperationOutput::WriteToRegister(Reg(0), Value("(1 * 2)".to_string()))
        );
        assert_eq!(mul.get_complete_cycle(), OperationLatency::MUL);
        assert_eq!(mul.get_instruction(), 0);
    }
}
